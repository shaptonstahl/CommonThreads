{
    "contents" : "#' CommonThreads\n\n# Remove detrius and start with a clean session\nsource(\"http://www.haptonstahl.org/R/Decruft/Decruft.R\")\n\n#####  Load libraries  #####\nsource(\"http://www.haptonstahl.org/R/usePackage/usePackage.R\")  # provides UsePackage\nUsePackage(\"dummies\")\n\n#####  Set options  #####\n# options(stringsAsFactors = FALSE)\n\n#####  Load functions  #####\n\n#####  DataFrameClasses  #####\n#' Retrieve the class of each column in a data.frame\n#'\n#' A longer description of the function.  This can be perhaps\n#' a paragraph, perhaps more than one.\n#' \n#' @param X data.frame.\n#' @return character vector with names of classes of each column of X\n#' @export\n#' @seealso \\code{\\link{Related function}}\n#' @references\n#' Include papers, Web sites, etc.\n#' \\url{http://www.haptonstahl.org/R}\n#' @author Stephen R. Haptonstahl \\email{srh@@haptonstahl.org}\n#' @examples\n#' data(iris)   # provides example data\n#' DataFrameClasses(iris)\nDataFrameClasses <- function(X) {\n  # Guardians\n  stopifnot(class(X) == \"data.frame\")\n  \n  # perform the function\n  out <- sapply(1:ncol(X), function(i) class(X[,i]))\n  \n  # prepare and return the output\n  return(out)\n}\n#' data(iris)   # provides example data\n#' DataFrameClasses(iris)\n#####\n\n#####  is.subset  #####\n#' Checks to see if the elements of one vector/array are contained\n#' in another vector/array\n#'\n#' @param x vector or coercible to one\n#' @param y vector or coercible to one\n#' @return logical singleton\n#' @export\n#' @seealso \\code{\\link{CommonThreads}}\n#' @references\n#' Include papers, Web sites, etc.\n#' \\url{http://www.haptonstahl.org/R}\n#' @author Stephen R. Haptonstahl \\email{srh@@haptonstahl.org}\n#' @examples\n#' is.subset(1:3, 1:5)  # returns TRUE\n#' is.subset(1:5, 1:3)  # returns FALSE\n#' is.subset(array(1:9, dim=c(3,3)), c(1:100))  # returns TRUE\n#' is.subset(matrix(1:200, ncol=2), array(1:125, dim=c(5,5,5)))  # returns FALSE\nis.subset <- function(x, y) {\n  # Guardians\n  stopifnot(is(x, \"vector\"),\n            is(y, \"vector\")\n  )\n  \n  # deal with default and missing values\n  \n  # perform the function\n  out <- all(x %in% y)\n  # prepare and return the output\n  return(out)\n}\n#####\n\n#####  CommonThreads  #####\n#' Which variables best explain membership?\n#'\n#' Identify which variables explain best why these observations/nodes\n#' are distinct from those observations.\n#' \n#' @param X data.frame of observations\n#' @param members numeric vector of rows included or logical vector with TRUE for members\n#' @param min.nonzero.certainty numeric p-value must be below 1-min.nonzero.certainty to report result for a coefficient\n#' @return data.frame with variables column.name, effect, prob.not.zero\n#' @export\n#' @seealso \\code{\\link{CommonThreadDescriptions}}\n#' @references\n#' Include papers, Web sites, etc.\n#' \\url{http://www.haptonstahl.org/R}\n#' @author Stephen R. Haptonstahl \\email{srh@@haptonstahl.org}\n#' @examples\n#' data(iris)\n#' observations.selected <- sample(1:nrow(iris), 30)\n#' CommonThreads(X=iris, members=observations.selected)\n#' CommonThreads(X=iris, members=observations.selected, min.nonzero.certainty=.5)\nCommonThreads <- function(X,\n                          members,\n                          min.nonzero.certainty=.75) {\n  # Guardians\n  stopifnot(is(X, \"data.frame\") && nrow(X) >= 2,\n            (is(members, \"logical\") && length(members) == nrow(X)) || \n              (is(members, \"numeric\") && is.subset(members, 1:nrow(X))),\n            min.nonzero.certainty > 0 && min.nonzero.certainty < 1\n  )\n  \n  ###  deal with default and missing values  ###\n  \n  # Will work with Z internally\n  Z <- dummy.data.frame(X, sep=\".\")\n  Z <- scale(Z)\n  \n  # code dependent variable, taking out repeated elements\n  dep.var.name <- paste(\"cty\", paste(sample(letters, 10), collapse=\"\"), sep=\".\")  # random name to avoid colision\n  if( is(members, \"logical\") ) members <- which(members)\n  members <- unique(members)  # remove duplicate indices\n  dep.var <- rep(0, nrow(X))\n  dep.var[members] <- 1\n  Z <- data.frame(dep.var, Z)\n  names(Z)[1] <- dep.var.name\n  \n  # perform the function\n  probit.res <- glm(formula(paste(dep.var.name, \"~ .\")), \n                    data=Z, \n                    family=binomial(link=\"probit\"))\n  \n  # prepare and return the output\n  out <- summary(probit.res)$coefficients[-1,]\n  out <- out[sort(abs(out[,1]), decreasing=TRUE, index.return=TRUE)$ix,]  # sort by absolute value of coefficient\n  out <- out[out[,4] < 1 - min.nonzero.certainty,]\n  out <- data.frame(rownames(out), out)\n  names(out) <- c(\"column.name\", \"effect\", \"std.err\", \"z.value\", \"p.value\")\n  out$prob.not.zero <- 1 - out$p.value\n  out <- out[,c(\"column.name\", \"effect\", \"prob.not.zero\")]\n  rownames(out) <- NULL\n  \n  return(out)\n}\n#####",
    "created" : 1369708743241.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "946422461",
    "id" : "3F27C0F",
    "lastKnownWriteTime" : 1392594385,
    "path" : "~/GitHub/CommonThreads/exp/experiment.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}